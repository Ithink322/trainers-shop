"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.create = void 0;
const vls = require("vls");
const html = require("vscode-html-languageservice");
const fs = require("fs");
const path = require("path");
const userSnippetDir_1 = require("./userSnippetDir");
const triggerCharacters = {
    // https://github.com/microsoft/vscode/blob/09850876e652688fb142e2e19fd00fd38c0bc4ba/extensions/html-language-features/server/src/htmlServer.ts#L183
    triggerCharacters: ['.', ':', '<', '"', '=', '/', /* vue event shorthand */ '@'],
};
function create() {
    return (ctx) => {
        if (!ctx) {
            return triggerCharacters;
        }
        const htmlDocuments = new WeakMap();
        const uriToPackageJsonPath = new Map();
        const htmlDataProviders = new Map();
        const htmlLs = html.getLanguageService();
        const snippetManager = new vls.SnippetManager(getSnippetsPath() ?? '' /* TODO: find snippets folder from document path */, (0, userSnippetDir_1.getGlobalSnippetDir)(false));
        const scaffoldSnippetSources = {
            workspace: '💼',
            user: '🗒️',
            vetur: '✌'
        };
        return {
            ...triggerCharacters,
            isAdditionalCompletion: true,
            provideCompletionItems(document, position, context) {
                let result;
                htmlWorker(document, htmlDocument => {
                    result = htmlLs.doComplete(document, position, htmlDocument);
                });
                if (!context?.triggerCharacter) {
                    vueWorker(document, () => {
                        const items = snippetManager.completeSnippets(scaffoldSnippetSources);
                        if (items.length) {
                            result = {
                                isIncomplete: false,
                                items: items,
                            };
                        }
                    });
                }
                return result;
            },
            provideHover(document, position) {
                return htmlWorker(document, htmlDocument => {
                    return htmlLs.doHover(document, position, htmlDocument);
                });
            },
            provideDocumentSemanticTokens(document, range) {
                return htmlWorker(document, () => {
                    const packageJsonPath = getPackageJsonPath(document);
                    if (!packageJsonPath)
                        return;
                    const dtmlDataProviders = getHtmlDataProviders(packageJsonPath);
                    const components = new Set(dtmlDataProviders.map(provider => provider.getId() === 'html5' ? [] : provider.provideTags().map(tag => tag.name)).flat());
                    const offsetRange = {
                        start: document.offsetAt(range.start),
                        end: document.offsetAt(range.end),
                    };
                    const scanner = htmlLs.createScanner(document.getText());
                    const result = [];
                    let token = scanner.scan();
                    while (token !== html.TokenType.EOS) {
                        const tokenOffset = scanner.getTokenOffset();
                        // TODO: fix source map perf and break in while condition
                        if (tokenOffset > offsetRange.end)
                            break;
                        if (tokenOffset >= offsetRange.start && (token === html.TokenType.StartTag || token === html.TokenType.EndTag)) {
                            const tokenText = scanner.getTokenText();
                            if (components.has(tokenText) || tokenText.indexOf('.') >= 0) {
                                const tokenLength = scanner.getTokenLength();
                                const tokenPosition = document.positionAt(tokenOffset);
                                if (components.has(tokenText)) {
                                    result.push([tokenPosition.line, tokenPosition.character, tokenLength, 10 /* 10: function, 12: component */, 0]);
                                }
                            }
                        }
                        token = scanner.scan();
                    }
                    return result;
                });
            },
        };
        function htmlWorker(document, callback) {
            const htmlDocument = getHtmlDocument(document);
            if (!htmlDocument)
                return;
            const packageJsonPath = getPackageJsonPath(document);
            if (!packageJsonPath)
                return;
            htmlLs.setDataProviders(false, getHtmlDataProviders(packageJsonPath));
            return callback(htmlDocument);
        }
        function vueWorker(document, callback) {
            if (document.languageId === 'vue') {
                return callback();
            }
        }
        function getPackageJsonPath(document) {
            let packageJsonPath = uriToPackageJsonPath.get(document.uri);
            if (!packageJsonPath) {
                let lastDirname = ctx.env.uriToFileName(document.uri);
                while (true) {
                    const dirname = path.dirname(lastDirname);
                    if (dirname === lastDirname) {
                        break;
                    }
                    if (fs.existsSync(dirname + '/package.json')) {
                        packageJsonPath = dirname + '/package.json';
                        break;
                    }
                    lastDirname = dirname;
                }
                uriToPackageJsonPath.set(document.uri, packageJsonPath);
            }
            return packageJsonPath;
        }
        function getSnippetsPath() {
            const fsPath = __filename;
            let lastDirname = fsPath;
            let snippetsPath;
            while (true) {
                const dirname = path.dirname(lastDirname);
                if (dirname === lastDirname) {
                    break;
                }
                if (fs.existsSync(dirname + '/.vscode/vetur/snippets')) {
                    snippetsPath = dirname + '/.vscode/vetur/snippets';
                    break;
                }
                lastDirname = dirname;
            }
            return snippetsPath;
        }
        function getHtmlDataProviders(packageJsonPath) {
            let dataProviders = htmlDataProviders.get(packageJsonPath);
            if (!dataProviders) {
                const tagProviderSettings = vls.getTagProviderSettings(packageJsonPath);
                const enabledTagProviders = vls.getEnabledTagProviders(tagProviderSettings);
                dataProviders = enabledTagProviders.map(provider => {
                    const htmlProvider = {
                        getId: provider.getId,
                        isApplicable() {
                            return true;
                        },
                        provideTags() {
                            const tags = [];
                            provider.collectTags((tag, documentation) => {
                                tags.push({
                                    name: tag,
                                    description: documentation,
                                    attributes: [],
                                });
                            });
                            return tags;
                        },
                        provideAttributes(tag) {
                            const attributes = [];
                            provider.collectAttributes(tag, (attribute, type, documentation) => {
                                if (attribute.startsWith('v-') || attribute.startsWith('@')) {
                                    attributes.push({
                                        name: attribute,
                                        valueSet: type,
                                        description: documentation,
                                    });
                                }
                                else {
                                    attributes.push({
                                        name: 'v-bind:' + attribute,
                                        valueSet: type,
                                        description: documentation,
                                    });
                                    attributes.push({
                                        name: ':' + attribute,
                                        valueSet: type,
                                        description: documentation,
                                    });
                                    attributes.push({
                                        name: attribute,
                                        valueSet: type,
                                        description: documentation,
                                    });
                                }
                            });
                            return attributes;
                        },
                        provideValues(tag, attribute) {
                            const values = [];
                            provider.collectValues(tag, attribute, value => {
                                values.push({
                                    name: value,
                                });
                            });
                            return values;
                        },
                    };
                    return htmlProvider;
                });
                htmlDataProviders.set(packageJsonPath, dataProviders);
            }
            return dataProviders;
        }
        function getHtmlDocument(document) {
            if (document.languageId !== 'html')
                return;
            let htmlDocument = htmlDocuments.get(document);
            if (!htmlDocument) {
                htmlDocument = htmlLs.parseHTMLDocument(document);
                htmlDocuments.set(document, htmlDocument);
            }
            return htmlDocument;
        }
    };
}
exports.create = create;
exports.default = create;
//# sourceMappingURL=index.js.map